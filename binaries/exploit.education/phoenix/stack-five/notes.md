# notes

## General notes

While I could have used some pre-existing shellcode, I chose not to for
multiple reasons:

1. I wanted to make my own shellcode to see if I could do it. I wanted it to
   produce similar output to the prior challenges.
2. I briefly tried to make some execve(/bin/sh) shellcode samples work, but
   none of the samples I tried worked without modification. I was likely using
   them wrong. Re-using other people's shellcode would have likely been the
   fastest way to complete this challenge, but I wanted to go through the
   exercise of writing and debugging my own shellcode.

I wanted to use "Congratulations, you've finished phoenix/stack-five :-) Well
done!", but it was too long for a reliable NOP sled to work. So I settled on
"Congratulations!" so that I could have a longer, more reliable NOP sled. I
picked an address roughly in the center of the NOP sled when the program was
loaded into gdb.

Getting the address of the "Congratulations!" string via a jmp -> call approach
resulted in a segfault, so I needed to calculate the address from within the
shellcode (`lea rsi, [rsp-0x17]`).

0x0a was a bad character due to the `gets` function, so I could have chosen to
just not add a newline. But because the newline issue caused me so much trouble
while making this shellcode (I didn't realize 0x0a was a bad character for a
while), I decided to make things even more unnecessarily complex by calculating
where the newline should be in the string, saving a 0x9 character to a
register, incrementing the register so that its value was 0xa, and saving that
value to where the newline should be in the string.

I am only able to get a reliable exploit when running the solution from within
an interactive Vagrant ssh connection. It does not work inside a Docker
container and does not work when running the solution using the `vagrant ssh
-c` syntax. I think this is due to ASLR, but I'm not sure. Given the amount of
time I spent getting to a reliable exploit in one environment, I'm not
currently interested in making it work in more environments.

## Null bytes

I used xor to zero out registers, followed by a byte move to avoid nulls. It
wasn't necessary, but I wanted to experiment with avoiding bad characters, such
as nulls. I'm fairly certain 0x00 was not a bad character for this exercise,
whereas 0x0a was a bad character.

```assembly
  401002:       b8 04 00 00 00          mov    $0x4,%eax
```

vs

```assembly
  401002:       48 31 c0                xor    %rax,%rax
  401005:       b0 04                   mov    $0x4,%al
```

## gdb

Reference gdb commands that I used to debug the shellcode:

```text
define fn
ni
x/10i $rip
end
b *0x004005a3
run < /vagrant/stack-five/payload.bin
fn
```
